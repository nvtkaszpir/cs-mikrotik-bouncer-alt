{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CrowdSec MikroTik Bouncer Alternative","text":""},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This project is not affiliated in any way with CrowdSec nor MikroTik, use at your own risk.</p>"},{"location":"#about","title":"About","text":"<p>This repository aims to implement the MikroTik router as CrowdSec Remediation Component (formerly known as bouncer), thus making it easier to block malicious IP to access your services. For this it leverages MikroTik API to populate a dynamic Firewall Address List.</p> <p>This started as a fork of <code>CrowdSec Bouncer for MikroTik RouterOS appliance</code> by funkolabs, but now it is living as standalone project, named as <code>Alternative</code> (or in short <code>alt</code>), to avoid confusion with the original repo and related integrations.</p> <p>Notice it works differently, some elements are common in the config, so the migration is quite easy, but make sure to read carefully this readme file for more details.</p>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#app-architecture","title":"App architecture","text":"sequenceDiagram   participant CrowdSec API   participant Bouncer   participant Mikrotik    Bouncer -&gt;&gt;+ CrowdSec API: login    rect rgba(0, 0, 255, .25)   loop Cache Update flow     CrowdSec API -&gt;&gt;+ Bouncer: get decisions as stream&lt;br/&gt;insert/update/remove item into cache     Bouncer -&gt;&gt;+ Bouncer: trigger MikroTik update if needed   end   end     rect rgba(255, 255, 0, .25)   loop Cache TTL     Bouncer -&gt;&gt;+ Bouncer: auto remove expired items from cache due TTL   end   end    rect rgba(255, 0, 0, .25)   loop Mikrotik configuration: &lt;br/&gt;every 1h or on incoming decision       Bouncer -&gt;&gt;+ Bouncer: create new address-list name       Bouncer -&gt;&gt; Mikrotik: connection open        loop over each item in the cache           Bouncer -&gt;&gt; Mikrotik: insert address to new address-list with ttl 4h       end       Bouncer -&gt;&gt; Mikrotik: update firewall rule to use new address-list       Bouncer -&gt;&gt; Mikrotik: connection close   end   end    rect rgba(0, 255, 0, .25)   loop Mikrotik address-list lifecycle: every 30s     Mikrotik -&gt;&gt;+ Mikrotik: check if address in any address-list should expire     Mikrotik -&gt;&gt;+ Mikrotik: if address-list empty then delete address-list   end   end    loop Metrics     Bouncer -&gt;&gt;+ Bouncer: update TTLCache metrics   end"},{"location":"#example-appliances","title":"Example appliances","text":""},{"location":"#processing-syslog-logs-from-mikrotik","title":"Processing syslog logs from MikroTik","text":"sequenceDiagram   IP 1.2.3.4 -&gt;&gt; Mikrotik: incoming request   Mikrotik -&gt;&gt; Log processor: send syslog messages from firewall   Log processor -&gt;&gt; Log processor: detect port scans   Log processor -&gt;&gt; Crowdsec LAPI: malicious activity detected for IP 1.2.3.4   Crowdsec LAPI -&gt;&gt; Crowdsec LAPI: ban 1.2.3.4   Crowdsec LAPI -&gt;&gt; Mikrotik Bouncer: stream bans   Mikrotik Bouncer -&gt;&gt; Mikrotik: update address lists, block 1.2.3.4   IP 1.2.3.4 --x  Mikrotik: drop traffic"},{"location":"#blocking-traffic-at-the-edge","title":"Blocking traffic at the edge","text":"sequenceDiagram   IP 1.2.3.4 --&gt; Mikrotik: incoming request   Mikrotik -&gt;&gt; Load Balancer: NAT traffic for web   Load Balancer -&gt;&gt; Web server pool: lad balance traffic to web servers   Web server pool -&gt;&gt; Crowdsec LAPI: malicious activity detected for IP 1.2.3.4   Crowdsec LAPI -&gt;&gt; Crowdsec LAPI: ban 1.2.3.4   Crowdsec LAPI -&gt;&gt; Mikrotik Bouncer: stream bans   Mikrotik Bouncer -&gt;&gt; Mikrotik: update address lists, block 1.2.3.4   IP 1.2.3.4 --x  Mikrotik: drop traffic"},{"location":"comparison/","title":"Comparison to other solutions","text":""},{"location":"comparison/#funkolabscs-mikrotik-bouncer","title":"funkolabs/cs-mikrotik-bouncer","text":"<p>Funkolabs version tries to dynamically update addresses in address lists on the MikroTik device. This has some disadvantages:</p> <ul> <li> <p>it fetches addresses from a single address-list from the routers,   then used it as cache, meanwhile it was also listening to the decisions   from the CrowdSec LAPI, and then tries to update the addresses in the MikroTik.   So generally bouncer was doing a diff between upstream and MikroTik device,   which is complex</p> </li> <li> <p>Doing <code>ip address find</code> on the MikroTik is slow, on certain devices this is   VERY slow, making noticeable load on the CPU of the device</p> </li> <li> <p>above caused that some devices were not blocking addresses fast enough,   or some addresses were not blocked at all, thus the diff process was   lagging behind the main update loop until there was a noticeable desynchronization   which could be solved only by the app restart</p> </li> <li> <p>some people mitigated it with scheduled app restarts after few hours,   effectively making cache not really useful</p> </li> <li> <p>in addition it kept constant connections to the MikroTik device, I am not sure   how it handled network errors - maybe crashes in containers helped it to   auto recover :)</p> </li> </ul> <p>This fork works differently:</p> <ul> <li> <p>there is no need to fetch addresses from the MikroTik device at all</p> </li> <li> <p>listen for the decisions from Crowdsec LAPI and compare it with local cache</p> </li> <li> <p>if there are differences between the cache such as add/delete/update   then process the addresses</p> </li> <li> <p>in separate loop walk over addresses in local cache,   and only then connect to the MikroTik device</p> </li> <li> <p>add address to a NEW address-list on the MikroTik,   optionally prior inserting the address shorten expiry time to desired value   to say 4h ( I named that as <code>truncate</code>) .</p> </li> <li> <p>if there were no errors then alter specific existing firewall rules to use   that new address-list - the swap is quick and atomic</p> </li> </ul> <p>This way a new list it created on MikroTik device with addresses with updated timeout values.</p> <p>The old list will auto-expire after certain time, so it's good if this is short living one say 4h - default basic CrowdSec configuration updates addresses at least once per hour.</p>"},{"location":"comparison/#native-crowdsec-and-mikrotik-integration-via-api","title":"Native CrowdSec and Mikrotik integration via API","text":"<p>As described at docs integrations/mikrotik will be called <code>api-integration</code> below.</p> <ul> <li> <p><code>api-integration</code> requires MikroTik device to support ingesting blocklists.</p> </li> <li> <p><code>api-integration</code> exposes list of currently blocked addresses only,   and requires script on the MikroTik, wich will parse that imported blocklist.</p> </li> <li> <p><code>api-integration</code> script on mikrotik first deletes existing addresses from   address-list named <code>crowdsec-integration</code> and then inserts new entries   Unfortunately address removal can be slow on certain devices.</p> </li> <li> <p>As of the current date (2025.07.06) only firewall filter is supported,   anything else requires custom scripting.</p> </li> </ul> <p>See below for more details, which are shared with <code>crowdsecurity/cs-blocklist-mirror</code>.</p>"},{"location":"comparison/#crowdsecuritycs-blocklist-mirror","title":"crowdsecurity/cs-blocklist-mirror","text":"<p>crowdsecurity/cs-blocklist-mirror</p> <ul> <li> <p><code>cs-blocklist-mirror</code> runs similarly to <code>api-integration</code> and requires   MikroTik device to support ingesting blocklists and script on the device.</p> </li> <li> <p><code>cs-blocklist-mirror</code> exposes web endpoint which allows to fetch address list   and process it via script which runs on the MikroTik in scheduled intervals</p> </li> <li> <p>this means that <code>cs-blocklist-mirror</code> runs let say once per hour.   The script can be in plain ip address list (and custom scripting on MikroTik)   or prepared script (golang template baked into the app).   By default addresses are managed in single predefined address-list.   Unfortunately address removal can be slow on certain devices.</p> </li> <li> <p>cs-mikrotik-bouncer-alt can run in scheduled intervals let say once per   hour, just as tools above.</p> </li> <li> <p>cs-mikrotik-bouncer-alt can actively listen to the incoming streaming   decisions from the CrowdSec LAPI and issue firewall update immediately, within   seconds, and not minutes (depends on the config).</p> </li> <li> <p>cs-mikrotik-bouncer-alt creates new address list with active bans and then   changes firewall rules to use new address list</p> </li> <li> <p><code>cs-blocklist-mirror</code> can host single address list accessible from multiple devices   at once, lists is in pull mode only</p> </li> <li> <p>cs-mikrotik-bouncer-alt manages single device in push mode,   so each device needs separate running process (systemd service/container)   to talk to remote MikroTik device.</p> </li> </ul>"},{"location":"config.bouncer/","title":"Prepare config for the app","text":"<p>Copy <code>env.dist</code> as <code>.env</code> and edit its content environmental variables.</p>"},{"location":"config.bouncer/#register-bouncer-in-crowdsec-lapi","title":"Register bouncer in Crowdsec LAPI","text":"<p>Generate a bouncer API key following CrowdSec documentation, get a bouncer API key from your CrowdSec with a command</p> <pre><code>cscli bouncers add mikrotik-bouncer\n</code></pre> <p>Copy the API key printed. You WILL NOT be able the get it again. Paste this API key as the value for bouncer environment variable <code>CROWDSEC_BOUNCER_API_KEY</code></p>"},{"location":"config.bouncer/#set-firewall-rules-to-control","title":"Set firewall rules to control","text":"<p>In previous steps you can get the required firewall rules which will be used to be updated.</p> <p>Adjust other variables in .env file as needed, especially host to MikroTik device and CrowdSec endpoint. See section below.</p>"},{"location":"config.bouncer/#configuration-options","title":"Configuration options","text":"<p>The bouncer configuration is made via environment variables.</p> <p>TODO: use golang docstring generator to list env vars and settings</p>"},{"location":"config.bouncer/#crowdsec_bouncer_api_key","title":"CROWDSEC_BOUNCER_API_KEY","text":"<p><code>CROWDSEC_BOUNCER_API_KEY</code> - default value: unset, required, CrowdSec bouncer API key required to be authorized to request local API.</p>"},{"location":"config.bouncer/#crowdsec_url","title":"CROWDSEC_URL","text":"<p><code>CROWDSEC_URL</code> - default value: <code>http://crowdsec:8080/</code>, required, Host and port of CrowdSec LAPI agent.</p>"},{"location":"config.bouncer/#crowdsec_origins","title":"CROWDSEC_ORIGINS","text":"<p><code>CROWDSEC_ORIGINS</code> - default value: unset, optional, Space separated list of CrowdSec origins to filter from LAPI, in example <code>crowdsec cscli</code>.</p>"},{"location":"config.bouncer/#debug_decisions_max","title":"DEBUG_DECISIONS_MAX","text":"<p><code>DEBUG_DECISIONS_MAX</code> - default value: <code>-1</code>, optional, Set number of decisions to process at max, useful for debugging. Set to 3 to make things less spammy.</p>"},{"location":"config.bouncer/#log_level","title":"LOG_LEVEL","text":"<p><code>LOG_LEVEL</code> - default value: <code>1</code>, optional, Minimum log level for bouncer in zerolog levels</p>"},{"location":"config.bouncer/#log_format_json","title":"LOG_FORMAT_JSON","text":"<p><code>LOG_FORMAT_JSON</code> - default value: <code>true</code>, optional, Use logs in JSON format, set to <code>false</code> for plain text zerolog format with key=value, useful only in certain debug sessions</p>"},{"location":"config.bouncer/#mikrotik_host","title":"MIKROTIK_HOST","text":"<p><code>MIKROTIK_HOST</code> - default value: unset, required, MikroTik device address to access RouterOS API ( <code>ip:port</code>)</p>"},{"location":"config.bouncer/#mikrotik_user","title":"MIKROTIK_USER","text":"<p><code>MIKROTIK_USER</code> - default value: unset, required, Mikrotik device username to access RouterOS API</p>"},{"location":"config.bouncer/#mikrotik_pass","title":"MIKROTIK_PASS","text":"<p><code>MIKROTIK_PASS</code> - default value: unset, required, Mikrotik device password to access RouterOS API</p>"},{"location":"config.bouncer/#mikrotik_tls","title":"MIKROTIK_TLS","text":"<p><code>MIKROTIK_TLS</code> -  default value: <code>true</code>, optional, User TLS to connect to MikroTik API,</p>"},{"location":"config.bouncer/#mikrotik_ipv4","title":"MIKROTIK_IPV4","text":"<p><code>MIKROTIK_IPV4</code> - default value: <code>true</code>, optional, IPv4 support, set to <code>true</code> to enable processing IPv4 blocklists</p>"},{"location":"config.bouncer/#mikrotik_ipv6","title":"MIKROTIK_IPV6","text":"<p><code>MIKROTIK_IPV6</code> - default value: <code>true</code>,  optional, IPv6 support, set to <code>true</code> to enable processing IPv6 blocklists</p>"},{"location":"config.bouncer/#mikrotik_firewall_filter_enable","title":"MIKROTIK_FIREWALL_FILTER_ENABLE","text":"<p><code>MIKROTIK_FIREWALL_FILTER_ENABLE</code> - default value: <code>true</code>, optional, enable updating firewall filter rules (filter input, forward, output) See Firewall Filter or Raw for more details.</p>"},{"location":"config.bouncer/#ip_firewall_filter_rules_src","title":"IP_FIREWALL_FILTER_RULES_SRC","text":"<p><code>IP_FIREWALL_FILTER_RULES_SRC</code> - default value: unset, required if <code>MIKROTIK_IPV4</code> is set to true, comma separated numbers of IPv4 firewall filter rules to update on access-list change, and to set src-address-list in it, those are created during configuration, for example <code>1,2</code> (filter input, forward, output)</p>"},{"location":"config.bouncer/#ip_firewall_filter_rules_dst","title":"IP_FIREWALL_FILTER_RULES_DST","text":"<p><code>IP_FIREWALL_FILTER_RULES_DST</code> - default value: unset, required if <code>MIKROTIK_IPV4</code> is set to true, comma separated numbers of IPv4 firewall filter rules to update on access-list change, and to set dst-address-list in it, those are created during configuration, for example <code>3,4</code> (filter input, forward, output)</p>"},{"location":"config.bouncer/#ipv6_firewall_filter_rules_src","title":"IPV6_FIREWALL_FILTER_RULES_SRC","text":"<p><code>IPV6_FIREWALL_FILTER_RULES_SRC</code> - default value: unset, required if <code>MIKROTIK_IPV6</code> is set to true, comma separated numbers of IPv6 firewall filter rules to update on access-list change, and to set src-address-list in it, those are created during configuration , for example <code>0,1</code> (filter input, forward, output)</p>"},{"location":"config.bouncer/#ipv6_firewall_filter_rules_dst","title":"IPV6_FIREWALL_FILTER_RULES_DST","text":"<p><code>IPV6_FIREWALL_FILTER_RULES_DST</code> - default value: unset, required if <code>MIKROTIK_IPV6</code> is set to true, comma separated numbers of IPv6 firewall filter rules to update on access-list change, and to set dst-address-list in it, those are created during configuration , for example <code>2,3</code> (filter input, forward, output)</p>"},{"location":"config.bouncer/#mikrotik_firewall_raw_enable","title":"MIKROTIK_FIREWALL_RAW_ENABLE","text":"<p><code>MIKROTIK_FIREWALL_RAW_ENABLE</code> - default value: <code>true</code>, optional, enable updating firewall raw rules (raw prerouting, output). See Firewall Filter or Raw for more details.</p>"},{"location":"config.bouncer/#ip_firewall_raw_rules_src","title":"IP_FIREWALL_RAW_RULES_SRC","text":"<p><code>IP_FIREWALL_RAW_RULES_SRC</code> - default value: unset, required if <code>MIKROTIK_IPV4</code> is set to true, comma separated numbers of IPv4 firewall raw rules to update on access-list change, and to set src-address-list in it, those are created during configuration, for example <code>1</code> (raw prerouting, output)</p>"},{"location":"config.bouncer/#ip_firewall_raw_rules_dst","title":"IP_FIREWALL_RAW_RULES_DST","text":"<p><code>IP_FIREWALL_RAW_RULES_DST</code> - default value: unset, required if <code>MIKROTIK_IPV4</code> is set to true, comma separated numbers of IPv4 firewall raw rules to update on access-list change, and to set dst-address-list in it, those are created during configuration, for example <code>2</code> (raw prerouting, output)</p>"},{"location":"config.bouncer/#ipv6_firewall_raw_rules_src","title":"IPV6_FIREWALL_RAW_RULES_SRC","text":"<p><code>IPV6_FIREWALL_RAW_RULES_SRC</code> - default value: unset, required if <code>MIKROTIK_IPV6</code> is set to true, comma separated numbers of IPv6 firewall raw rules to update on access-list change, and to set src-address-list in it, those are created during configuration , for example <code>0</code> (raw prerouting, output)</p>"},{"location":"config.bouncer/#ipv6_firewall_raw_rules_dst","title":"IPV6_FIREWALL_RAW_RULES_DST","text":"<p><code>IPV6_FIREWALL_RAW_RULES_DST</code> - default value: unset, required if <code>MIKROTIK_IPV6</code> is set to true, comma separated numbers of IPv6 firewall raw rules to update on access-list change, and to set dst-address-list in it, those are created during configuration , for example <code>1</code> (raw prerouting, output)</p>"},{"location":"config.bouncer/#mikrotik_address_list","title":"MIKROTIK_ADDRESS_LIST","text":"<p><code>MIKROTIK_ADDRESS_LIST</code> - default value: <code>crowdsec</code>, optional, prefix for target address-list in MikroTik device, no special chars, no spaces etc, generated name will be with a timestamp suffix, if you set it to <code>crowdsec</code> then access-list will be named as <code>crowdsec_2025-05-19_15-01-09</code> or something like it (local time),</p>"},{"location":"config.bouncer/#mikrotik_timeout","title":"MIKROTIK_TIMEOUT","text":"<p><code>MIKROTIK_TIMEOUT</code> - default value: <code>10s</code>, optional, set timeout when trying to connect to the MikroTik, recommended to keep it under <code>60s</code></p>"},{"location":"config.bouncer/#mikrotik_update_frequency","title":"MIKROTIK_UPDATE_FREQUENCY","text":"<p><code>MIKROTIK_UPDATE_FREQUENCY</code> - default value: <code>1h</code>, optional, Set default frequency to update MikroTik address-lists and firewall rules. This is useful if you have very low DEFAULT_TTL_MAX value.</p> <p>This is useful if you have disabled TRIGGER_ON_UPDATE, or enabled <code>USE_MAX_TTL=true</code> and set DEFAULT_TTL_MAX.</p>"},{"location":"config.bouncer/#use_max_ttl","title":"USE_MAX_TTL","text":"<p><code>USE_MAX_TTL</code> - default value: <code>false</code>, optional, Set to <code>true</code> if you want to truncate timeout for the address in address-list so that your address lists expire faster</p>"},{"location":"config.bouncer/#default_ttl_max","title":"DEFAULT_TTL_MAX","text":"<p><code>DEFAULT_TTL_MAX</code> - default value: <code>4h</code>, optional, If USE_MAX_TTL is <code>true</code>  and new address timeout is above DEFAULT_TTL_MAX then that address will have timeout set to USE_MAX_TTL value.</p> <p>For example new decision comes in, and address should be banned for 4 days, but <code>DEFAULT_TTL_MAX=4h</code> will make it to be added with <code>timeout=4h</code>. Notice that the original 4 day ban will be respected in the application cache or from incoming CrowdSec decisions, but on MikroTik it will have 4h.</p> <p>Yet it is good to quickly expire old address-lists automatically, because new ones will come in with refreshed entries for the same address IPs to block.</p> <p>Because CrowdSec publishes new lists at least once an hour then that address will be readded to the new list every hour until expires.</p> <p>This helps to avoid having thousands addresses in hundreds address-lists in the MikroTik.</p> <p>Recommended value is at least 2x longer than the frequency you get updates from the CrowdSec, so on basic setup 4h should be sufficient. For locations with possible network disruptions 8h or 16 would be recommended (but then why ban if there is no internet? :) ).</p> <p>For weaker/older devices it may be better to keep it really low like 2h.</p> <p>If you get frequent updates from your CrowdSec LAPI (say every 5 minutes), and you have TRIGGER_ON_UPDATE=true, then you could even set it to as low as 15min.</p> <p>Must be longer than MIKROTIK_UPDATE_FREQUENCY.</p>"},{"location":"config.bouncer/#trigger_on_update","title":"TRIGGER_ON_UPDATE","text":"<p><code>TRIGGER_ON_UPDATE</code> - default value: <code>true</code>, optional, if you set it to true, then trigger MikroTik address-list and firewall update immediately (look at TICKER_INTERVAL).</p> <p>This makes ban added from other tools being applied faster, but for the price of creating new address-list and firewall update. Effectively you really want this enabled, and also have USE_MAX_TTL set to say 4h for quicker old address expiration.</p> <p>If set to <code>false</code> then the address will not be banned until the next loop of the MIKROTIK_UPDATE_FREQUENCY is executed, so on default settings it may take up to 1h before address is banned.</p>"},{"location":"config.bouncer/#ticker_interval","title":"TICKER_INTERVAL","text":"<p><code>TICKER_INTERVAL</code> - default value: <code>10s</code>, optional how frequently process streamed decisions from CrowdSec LAPI,</p> <p>Notice this is a golang time.Duration format, but the value cannot be equal or less than <code>0s</code>.</p> <p>This will vary depending on the current length of the IP addresses to be blocked - so for example if you test with 4k addresses inserted and it takes 10s then adding 20k addresses may take more (let say 25s).</p> <p>The best if this is the total time used to update MikroTik address lists and firewall plus about 30% just to prevent bouncer stuck waiting to acquire lock for the update.</p> <p>If you get frequent delays in acquiring lock then try to increase this value higher, certain devices are quite slow and they need at least <code>30s</code> or <code>60s</code> for processing.</p> <p>Sometimes it is just better to buy better faster hardware.</p>"},{"location":"config.bouncer/#gomaxprocs","title":"GOMAXPROCS","text":"<p><code>GOMAXPROCS</code> - default value: unset (automatic number of processors), optional, Set default processes to use by golang app, especially useful to prevent it from getting excessively throttled in the containers, Recommended value <code>1</code>.</p>"},{"location":"config.bouncer/#metrics_address","title":"METRICS_ADDRESS","text":"<p><code>METRICS_ADDRESS</code> - default value: <code>:2112</code>, optional, Address to use to start metrics server in Prometheus format, metrics are exposed under <code>/metrics</code> path, without authorization (not implemented).</p>"},{"location":"config.bouncer/#tz","title":"TZ","text":"<p><code>TZ</code> - default value: unset, optional, set desired timezone, otherwise if empty then it will take local time from the machine it runs on. It affects logging and name of the address-list suffix created on the MikroTik device. Example <code>UTC</code> or <code>Europe/Warsaw</code>.</p>"},{"location":"config.mikrotik/","title":"MikroTik config","text":""},{"location":"config.mikrotik/#enable-mikrotik-routeros-api","title":"Enable MikroTik RouterOS API","text":"<p>See MikroTik RouterOS API</p>"},{"location":"config.mikrotik/#mikrotik-user","title":"MikroTik user","text":"<p>Add user to MikroTik to allow access via RouterOS API.</p> <pre><code>/user group add name=crowdsec policy=api,read,write\n/user add name=crowdsec-bouncer-user password=hunter2 group=crowdsec disabled=no\n</code></pre> <p>Remember to filter out access for the created user for given address only etc.</p>"},{"location":"config.mikrotik/#optional-firewall-rules-with-log-or-passthrough","title":"Optional - Firewall rules with Log or Passthrough","text":"<p>To avoid unexpected issues it is advised to change the new rules to <code>passthrough</code> so that you can see the number of packets that got through it.</p> <p>Additional logging should help in checking if the setup works as expected.</p> <p>If it works then change rules to <code>drop</code> one by one to make it actually workign as expected :)</p> <p>Below commands assume no logging and drop as default action.</p>"},{"location":"config.mikrotik/#firewall-ipv6-or-ipv4","title":"Firewall - IPv6 or IPv4","text":"<p>If you have dual-stacik (IPv6 and IPV4) available publicly, then enable both. If you dont have one then it's better to use the only one you have, because it speeds up device configuration and lowers consumed resources such as memory.</p>"},{"location":"config.mikrotik/#firewall-filter-or-raw","title":"Firewall - filter or raw","text":"<p>There is a difference between <code>firewall filter</code> and <code>firewall raw</code>, they serve different purposes and require different computing powers - in short <code>filter</code> is computationally heavier than <code>raw</code>, but allows doing more advanced traffic filtering such as connection tracking and layer 7 protocol detection.</p> <ul> <li>raw drops packets as early as possible, and they are stateless</li> <li>raw is processed before filter rules, so it can save resources such as cpu   and memory, especially if you are hitting device limits</li> <li>filter works after some other rules, like connection tracking   and thus they are stateful and allow better manipulation of certain use cases</li> <li>using raw rules only should be done only when dealing with specific use cases   such as DDOS (crowdsec is not really good at it, though)</li> </ul> <p>Which one to choose?</p> <ul> <li> <p>by default both are enabled, and first <code>raw</code> will drop most of the traffic,   thus <code>filter</code> shoudl have much less to process and thus not consume that much   resources if <code>raw</code> is not enabled.</p> </li> <li> <p>if the MikroTik device still struggles such as hitting limits of the cpu/memory   of the device then try to use <code>raw</code> mode only.</p> </li> </ul>"},{"location":"config.mikrotik/#creating-firewall-filter-rules","title":"Creating Firewall filter rules","text":""},{"location":"config.mikrotik/#creating-ipv6-firewall-filter-rules","title":"Creating IPv6 firewall filter rules","text":"<p>For IPv6 - create IPv6 'drop' filter rules in <code>input</code> and <code>forward</code> chain with the source address list set to <code>crowdsec</code> at the top.</p> <p>Below are snippets to use, make sure to replace <code>ether1</code> with your desired interface. Notice that if you use <code>place-before=0</code> then the order below is important, and for <code>dst-address-list</code> we do not define interface.</p> <pre><code>/ipv6 firewall filter \\\nadd action=drop dst-address-list=crowdsec chain=input \\\nplace-before=0 comment=\"crowdsec input drop rules - dst\"\n\n/ipv6 firewall filter \\\nadd action=drop dst-address-list=crowdsec chain=forward \\\nplace-before=0 comment=\"crowdsec forward drop rules - dst\"\n\n/ipv6 firewall filter \\\nadd action=drop src-address-list=crowdsec chain=input \\\nin-interface=ether1 \\\nplace-before=0 comment=\"crowdsec input drop rules - src\"\n\n/ipv6 firewall filter \\\nadd action=drop src-address-list=crowdsec chain=forward \\\nin-interface=ether1 \\\nplace-before=0 comment=\"crowdsec forward drop rules - src\"\n</code></pre> <p>The best would be to add them just after default <code>bad_ipv6</code> rules.</p>"},{"location":"config.mikrotik/#creating-ipv4-firewall-rules","title":"Creating IPv4 firewall rules","text":"<p>For IPv4 - create IP <code>drop</code> filter rules in <code>input</code> and <code>forward</code> chain with the source address list set to <code>crowdsec</code> at the top or just before generic packet counter rule.</p> <p>Below are snippets to use, make sure to replace <code>ether1</code> with your desired interface, assuming that rule 0 is a dummy passthrough for packet counting added by default to MikroTik, and rule 1 is whatever but we want to insert CrowdSec before it. Notice that if you use <code>place-before=1</code> then the order below is important, and for <code>dst-address-list</code> we do not define interface.</p> <pre><code>/ip firewall filter \\\nadd action=drop dst-address-list=crowdsec chain=input \\\nplace-before=1 comment=\"crowdsec input drop rules - dst\"\n\n/ip firewall filter \\\nadd action=drop dst-address-list=crowdsec chain=forward \\\nplace-before=1 comment=\"crowdsec forward drop rules - dst\"\n\n/ip firewall filter \\\nadd action=drop src-address-list=crowdsec chain=input \\\nin-interface=ether1 \\\nplace-before=1 comment=\"crowdsec input drop rules - src\"\n\n/ip firewall filter \\\nadd action=drop src-address-list=crowdsec chain=forward \\\nin-interface=ether1 \\\nplace-before=1 comment=\"crowdsec forward drop rules - src\"\n</code></pre>"},{"location":"config.mikrotik/#list-firewall-filter-rules","title":"List firewall filter rules","text":"<p>Get the list of firewall rules which were added, this will be needed later.</p> <pre><code>/ip firewall filter print without-paging\n\n/ipv6 firewall filter print without-paging\n</code></pre> <p>Write down numbers of the rules on the most left column.</p> <p>For example for IPv4:</p> <pre><code>&gt; /ip firewall filter print without-paging\n\nFlags: X - disabled, I - invalid; D - dynamic\n 0  D ;;; special dummy rule to show fasttrack counters\n      chain=forward action=passthrough\n\n 1    ;;; crowdsec forward drop rules - src\n      chain=forward action=drop src-address-list=crowdsec in-interface=ether1 log=no log-prefix=\"\"\n\n 2    ;;; crowdsec input drop rules - src\n      chain=input action=drop src-address-list=crowdsec in-interface=ether1 log=no log-prefix=\"\"\n\n 3    ;;; crowdsec forward drop rules - dst\n      chain=forward action=drop dst-address-list=crowdsec log=no log-prefix=\"\"\n\n 4    ;;; crowdsec input drop rules - dst\n      chain=input action=drop dst-address-list=crowdsec log=no log-prefix=\"\"\n\n 5    ;;; defconf: accept established,related,untracked\n      chain=input action=accept connection-state=established,related,untracked\n\n 6    ;;; defconf: drop invalid\n      chain=input action=drop connection-state=invalid\n</code></pre> <p>then:</p> <ul> <li><code>IP_FIREWALL_FILTER_RULES_SRC</code> would be <code>1,2</code></li> <li><code>IP_FIREWALL_FILTER_RULES_DST</code> would be <code>3,4</code></li> </ul> <p>Similar, for IPv6:</p> <pre><code>&gt; /ipv6 firewall filter print without-paging\nFlags: X - disabled, I - invalid; D - dynamic\n 0    ;;; crowdsec input drop rules - src\n      chain=input action=drop src-address-list=crowdsec in-interface=ether1 log=no log-prefix=\"\"\n\n 1    ;;; crowdsec forward drop rules - src\n      chain=forward action=drop src-address-list=crowdsec in-interface=ether1 log=no log-prefix=\"\"\n\n 2    ;;; crowdsec input drop rules - dst\n      chain=input action=drop log=no log-prefix=\"\"\n\n 3    ;;; crowdsec forward drop rules - dst\n      chain=forward action=drop log=no log-prefix=\"\"\n\n 4    ;;; defconf: drop invalid\n      chain=input action=drop connection-state=invalid\n\n 5    ;;; defconf: accept established,related,untracked\n      chain=input action=accept connection-state=established,related,untracked\n</code></pre> <p>then:</p> <ul> <li><code>IPV6_FIREWALL_FILTER_RULES_SRC</code> would be <code>0,1</code></li> <li><code>IPV6_FIREWALL_FILTER_RULES_DST</code> would be <code>2,3</code></li> </ul>"},{"location":"config.mikrotik/#creating-firewall-raw-rules","title":"Creating firewall raw rules","text":""},{"location":"config.mikrotik/#creating-ipv6-firewall-raw-rules","title":"Creating IPv6 firewall raw rules","text":"<p>For IPv6 - create IPv6 'drop' filter rules in <code>prerouting</code> and <code>output</code> chain with the source/destination address list set to <code>crowdsec</code> at the top.</p> <p>Below are snippets to use, make sure to replace <code>ether1</code> with your desired interface. Notice that if you use <code>place-before=0</code> then the order below is important.</p> <pre><code>/ipv6 firewall raw \\\nadd action=drop src-address-list=crowdsec chain=prerouting \\\nin-interface=ether1 \\\ncomment=\"crowdsec prerouting drop rules - src\"\n\n/ipv6 firewall raw \\\nadd action=drop dst-address-list=crowdsec chain=prerouting \\\ncomment=\"crowdsec prerouting drop rules - dst\"\n\n/ipv6 firewall raw \\\nadd action=drop dst-address-list=crowdsec chain=output \\\ncomment=\"crowdsec output drop rules - dst\"\n</code></pre> <p>The best would be to add them just after default <code>bad_ipv6</code> rules.</p>"},{"location":"config.mikrotik/#creating-ipv4-firewall-raw-rules","title":"Creating IPv4 firewall raw rules","text":"<p>For IPv4 - create IP <code>drop</code> filter rules in <code>prerouting</code> and <code>output</code> chain with the source/destination address list set to <code>crowdsec</code> at the top or just before generic packet counter rule.</p> <p>Below are snippets to use, make sure to replace <code>ether1</code> with your desired interface, assuming that rule 0 is a dummy passthrough for packet counting added by default to MikroTik, and rule 1 is whatever but we want to insert CrowdSec before it. Notice that if you use <code>place-before=1</code> then the order below is important.</p> <pre><code>/ip firewall raw \\\nadd action=drop src-address-list=crowdsec chain=prerouting \\\nin-interface=ether1 \\\ncomment=\"crowdsec prerouting drop rules - src\"\n\n/ip firewall raw \\\nadd action=drop dst-address-list=crowdsec chain=prerouting \\\ncomment=\"crowdsec prerouting drop rules - dst\"\n\n/ip firewall raw \\\nadd action=drop dst-address-list=crowdsec chain=output \\\ncomment=\"crowdsec output drop rules - dst\"\n</code></pre>"},{"location":"config.mikrotik/#list-firewall-raw-rules","title":"List firewall raw rules","text":"<p>Get the list of firewall rules which were added, this will be needed later.</p> <pre><code>/ip firewall raw print without-paging\n\n/ipv6 firewall raw print without-paging\n</code></pre> <p>Write down numbers of the rules on the most left column.</p> <p>For example for IPv4:</p> <pre><code>&gt; /ip firewall raw print without-paging\nFlags: X - disabled, I - invalid; D - dynamic\n 0  D ;;; special dummy rule to show fasttrack counters\n      chain=prerouting action=passthrough\n\n 1    ;;; crowdsec prerouting drop rules - src\n      chain=prerouting action=drop log=no log-prefix=\"\" src-address-list=crowdsec_2025-07-06_12-50-38\n\n 2    ;;; crowdsec output drop rules - dst\n      chain=output action=drop log=no log-prefix=\"\" dst-address-list=crowdsec_2025-07-06_12-50-38\n\n 3    ;;; crowdsec prerouting drop rules - dst\n      chain=prerouting action=drop log=no log-prefix=\"\" dst-address-list=crowdsec\n</code></pre> <p>then:</p> <ul> <li><code>IP_FIREWALL_RAW_RULES_DST</code> would be <code>2,3</code> (output,prerouting)</li> <li><code>IP_FIREWALL_RAW_RULES_SRC</code> would be <code>1</code> (prerouting)</li> </ul> <p>Similar, for IPv6:</p> <pre><code>&gt; /ipv6 firewall raw print without-paging\nFlags: X - disabled, I - invalid; D - dynamic\n 0    ;;; crowdsec prerouting drop rules - src\n      chain=prerouting action=drop in-interface=ether1 src-address-list=crowdsec\n\n 1    ;;; crowdsec prerouting drop rules - dst\n      chain=prerouting action=drop dst-address-list=crowdsec\n\n 2    ;;; crowdsec output drop rules - dst\n      chain=output action=drop dst-address-list=crowdsec\n</code></pre> <p>then:</p> <ul> <li><code>IPV6_FIREWALL_RAW_RULES_DST</code> would be <code>1,2</code> (output,prerouting)</li> <li><code>IPV6_FIREWALL_RAW_RULES_SRC</code> would be <code>0</code> (prerouting)</li> </ul>"},{"location":"deploy/","title":"Deployment","text":"<p>Only Linux deployments were tested as golang binary or as app running in containers such as Docker or k3s.</p>"},{"location":"deploy/#locally","title":"Locally","text":"<p>Make sure to have a golang installed locally, build binary without running:</p> <pre><code>make binary\n</code></pre> <p>Compile and run - edit <code>.env</code> file and then</p> <pre><code>export $(cat .env | xargs)\ngo run .\n</code></pre> <p>This will compile golang to binary and execute it.</p>"},{"location":"deploy/#docker","title":"Docker","text":"<p>I recommend using docker-compose, copy .env file there and start bouncer with</p> <pre><code>docker compose up\n</code></pre> <p>and investigate errors.</p> <p>If you want to test observability stack, then run</p> <pre><code>cd deploy/docker\ndocker compose -f docker-compose-stack.yaml up\n</code></pre> <p>and it will spawn minimal example of the bouncer, prometheus and grafana with an imported dashboard.</p> <p>URLs to access services locally:</p> <ul> <li>bouncer</li> <li>prometheus</li> <li>grafana user:pass <code>admin:admin</code></li> </ul> <p>The dasboard is imported only on grafana start so you can trigger container restart to reload the symlinked dashboard.</p>"},{"location":"deploy/#kubernetes","title":"Kubernetes","text":"<p>Kustomization files in kubernetes via kustomize with optional ServiceMonitor for automatic metric collections via Prometheus Operator.</p> <p>I suggest to deploy a bouncer in a separate namespace for each target MikroTik device, so it is easier to copy/paste kustomize base.</p> <p>If needed, change in ServiceMonitor relabelings if you want to distinguish bouncers in grafana (not implemented yet in the dashboard)</p> <pre><code>...\n  endpoints:\n    - port: metrics\n      scheme: http\n      interval: 10s\n      path: /metrics\n      relabelings:\n        - targetLabel: device # label key\n          replacement: hap-ax-3 # label value\n</code></pre>"},{"location":"develop/","title":"Contribution","text":"<p>For bigger changes please create an issue for discussion. This helps in deciding if your work is worth doing because it may not be accepted, due to various reasons.</p> <p>Feel free to maintain your own fork :)</p>"},{"location":"develop/#local-development","title":"Local Development","text":"<p>copy <code>env.dist</code> as <code>.env</code> and edit its values, then run:</p> <pre><code>export $(cat .env | xargs)\ngo run .\n</code></pre> <p>or if you want to also get the logs:</p> <pre><code>export $(cat .env | xargs)\ngo run . 2&gt;&amp;1| tee  out-$(date +\"%Y-%m-%d_%H-%M\").log\n</code></pre>"},{"location":"develop/#build-binary","title":"Build binary","text":"<pre><code>make binary\n</code></pre>"},{"location":"develop/#build-container-image","title":"Build container image","text":"<p>Build image using ko:</p> <pre><code>export KO_DOCKER_REPO=quay.io/kaszpir/\nmake image\n# edit deploy/docker/docker-compose.yaml such as image/tag\ndocker-compose up\n</code></pre>"},{"location":"develop/#other-mikrotik-commands","title":"Other MikroTik commands","text":"<pre><code>/ip firewall address-list remove [find where list=\"crowdsec\"]\n/ipv6 firewall address-list remove [find where list=\"crowdsec\"]\n\n# drop specific matching crowdsec prefix for given day\n/ip firewall address-list remove [find where list~\"^crowdsec_2025-05-20_.*\"]\n/ipv6 firewall address-list remove [find where list~\"^crowdsec_2025-05-20_.*\"]\n\n\n# drop all matching crowdsec prefix\n/ip firewall address-list remove [find where list~\"^crowdsec.*\"]\n/ipv6 firewall address-list remove [find where list~\"^crowdsec.*\"]\n\n# list ALL addresses in address-list, meaning any ip in address lists,\n# public addresses for lan/wan etc\n/ip firewall address-list print count-only\n/ipv6 firewall address-list print count-only\n\n# list ip in given address list (slow, memory/cpu intensive)\n/ip firewall address-list print brief without-paging   where list=crowdsec_2025-07-06_17-02-24\n\n# show just count of the ip addresses in given address list (slow, memory/cpu intensive)\n/ip firewall address-list print brief without-paging  count-only where list=crowdsec_2025-07-06_17-02-24\n</code></pre>"},{"location":"develop/#release","title":"Release","text":""},{"location":"develop/#preparation","title":"Preparation","text":"<ul> <li>before release run <code>make image</code> locally, will build and push image to quay</li> <li>test image for few hours.</li> </ul>"},{"location":"develop/#actual-release","title":"Actual Release","text":"<ul> <li>merge to master/main</li> <li>push tag - will trigger github action of building image</li> <li>prepare github release with details, especially about breaking changes</li> </ul>"},{"location":"features/","title":"Features","text":"<ul> <li> <p>set max time for IP address blocking - new decision comes in for 6 days,   but this tool changes it to a series of update 4h bans in MikroTik</p> </li> <li> <p>faster operation than other project, especially on older devices</p> </li> <li> <p>you can test it without affecting existing setup - creates new address-lists   and updates specific firewall rules which can be disabled, thus easy to   migrate from old to a new setup without breaking old configuration</p> </li> <li> <p>detailed messages in log, optionally plain text messages</p> </li> <li> <p>option to limit incoming decisions to desired value such as maximum 2 bans   to process, to make it easier to test setups prior production</p> </li> <li> <p>separate loop to fetch decisions from the CrowdSec LAPI, which inserts   addresses to the local cache</p> </li> <li> <p>separate loop to process addresses in the local cache and convert it to the   commands to create new MikroTik address-list and firewall update command   to use that newly created address-list</p> </li> <li> <p>use locking in the app to prevent concurrent address-list insertion within the   process (if you use concurrent bouncers then this still may happen anyway)</p> </li> <li> <p>create connection to the MikroTik only if update is needed</p> </li> <li> <p>designed to run in container without any privileges, read only container</p> </li> <li> <p>allow specifying blocking on the <code>filter firewall</code> or <code>filter raw</code> rules.   Using <code>filter raw</code> is faster and more performant, but it may not suit   all scenarios, see below for more details.</p> </li> <li> <p>prometheus metrics, which allows you to use grafana dashboards</p> </li> </ul> <p></p>"},{"location":"known.limitations/","title":"Known limitations","text":"<ul> <li> <p>code executes commands against single MikroTik device, this is by design,   and adding multi-device support is not planned due to the complexity.   Just run separate app instances with different configs - this way you can   much more easily test new configs on the same or different devices.   The app eats very low amount of resources (about 10 miliCore/24MB in peak)</p> </li> <li> <p>incoming decisions are added to the cache in separate loop than items added   to the Mikrotik, so there is a an about 10s delay between actual IP ban via   <code>cscli</code> and the firewall update on the MikroTik device.</p> </li> <li> <p>there is no graceful shutdown,   in worst case address-list is half populated but not applied to firewall,   or applied only to for example IPv4 (or IPv6),   so the old address list is still active, and when the new process spawns then   it will create a new list anyway</p> </li> <li> <p>tested with RouterOS 7.18.2, other versions</p> </li> <li> <p>using TLS to talk to Mikrotik RouterOS API was not tested yet</p> </li> </ul>"},{"location":"observability/","title":"Observability","text":"<p>For the detailed params see configuration options.</p>"},{"location":"observability/#logging","title":"Logging","text":"<p>Not much to say about logs.</p> <p>JSON log format by default, so formatting it in Loki should be more conveniet.</p> <p>Debug level floods a bit.</p>"},{"location":"observability/#metrics","title":"Metrics","text":"<p>If running locally see http://127.0.0.1:2112/metrics</p> <p>Some metrics appear after a while (usually under 60s).</p> <p></p> <p>Grafana dashboard source is in the repo under <code>observability/grafana/CrowdSec_bouncer-mikrotik.json</code></p> <p>Most important metrics:</p> <ul> <li> <p><code>mikrotik_client_total{func=\"connect\", result=\"error\"}</code> - number of errors   when trying to log in with MikroTik, especially when trying to connect,   see app logs for more details</p> </li> <li> <p><code>mikrotik_cmd_total{result=\"error\"}</code> - number of errors when trying to run commands    on with MikroTik after succesful logging in.</p> </li> <li> <p><code>mikrotik_cmd_total{result=\"success\"}</code> - number of commands successfully executed on MikroTik</p> </li> <li> <p><code>decisions_total{}</code> - processed incoming CrowdSec decisions to block/unblock addresses,   notice this does not mean they are added to the MikroTik, but to the app cache in memory.</p> </li> <li> <p><code>truncated_ttl_total{}</code> - number of ban truncated because they were too long</p> </li> <li> <p><code>mikrotik_cmd_duration_total</code> - duration of the commands executed when doing an update,   for example when using HAP AX3 this should usually be about 10 to 15 seconds per update   for inserting about 15.000 addresses to a new address-list</p> </li> <li> <p><code>lock_wait_duration_total</code> - time spent for waiting for the lock to run commands to update   a Mikrotik device, in general this should be microseconds, unless there is an existing update   and there is a lot of decisions to be processed.   There are two options to adjust - TICKER_INTERVAL, TRIGGER_ON_UPDATE, MIKROTIK_UPDATE_FREQUENCY.</p> </li> </ul>"},{"location":"requirements/","title":"Overview","text":"<p>For now, this service is mainly thought to be used in as an app in a container.</p> <p>If you need to build from source and run as standalone binary, please see deployment section.</p> <p>The app alone takes about up to 60MB or memory (depends on how large blocklists are). CPU usage is minimal, 10 milicores should be enough.</p> <p>Please see also Known Limitations.</p>"},{"location":"requirements/#prerequisites","title":"Prerequisites","text":"<ul> <li>You should have a MikroTik appliance and a CrowdSec instance running.</li> <li>The bouncer container is available as docker image under quay.io/kaszpir/cs-mikrotik-bouncer-alt.</li> <li>The running container must have access to CrowdSec LAPI   and to MikroTik RouterOS API.</li> </ul>"},{"location":"requirements/#configuration-and-deployment-overview","title":"Configuration and deployment overview","text":"<p>Read the following instructions below doing anything.</p> <ul> <li>Configure MikroTik device by adding user and firewall rules.</li> <li>Create a bouncer in CrowdSec.</li> <li>Prepare config for the bouncer</li> <li>Start the bouncer app via standalone binary or a container.</li> <li>Verify if all works as expected.</li> </ul>"},{"location":"todo/","title":"TODO","text":"<p>This section is a list of things to do in the future or never :)</p> <ul> <li> <p>change ServiceMonitor to PodMonitor, there is no need for a service, it's just   metrics anyway</p> </li> <li> <p>try to run container on the mikrotik</p> </li> <li> <p>add automatic ticker interval adjustments?</p> </li> <li> <p>double check if there is an error after adding address, then if we try to   update fw rule to new list:</p> </li> <li>if change to new list then it may be truncated ( missing entries)</li> <li> <p>if we keep to old list or don't add new list, then things can expire</p> </li> <li> <p>periodically ask MikroTik for <code>ip firewall address-list count-only</code> and make   metric from it?</p> </li> <li> <p>ko local   or <code>docker run -p 2112:2112 $(ko build ./cmd/app)</code> etc</p> </li> <li> <p>panic on no route to host in docker-compose up :D</p> </li> <li> <p>ip meging   ipaddres-go   will help to decrease number of address-list entries, and thus decrease time   needed to perform an update, and lowers memory usage on the device</p> </li> </ul> <p>from the basic experiment it was possible to decrease list size to 70% of initial   lenght, but the downside is that the ttl would be strictly set to defined length   such as 1h</p> <p>slurp all addresses from the cache and merge them,   iterate over the output and inject to mikrotik   but there are different ttl times so there would be a need to somehow extend/truncate them   easier to extend by inserting max time</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#application-start","title":"Application start","text":"<p>When app starts it should check for the required env vars and will check if they have a valid values.</p> <p>After that it will print in the log the passed down values with sensitive data masked.</p> <p>Connection to the CrowdSec API should happen within few seconds. If it crashes then usually you provided invalid Crowdsec API key.</p> <p>You can limit amount of messages by setting DEBUG_DECISIONS_MAX=1</p> <p>The most important things are reported as <code>error</code> messages in the logs.</p>"},{"location":"troubleshooting/#no-traffic-blocked","title":"No traffic blocked","text":"<p>Ensure that the firewall rules are high enough before other rules so that firewall is not skipping them.</p>"},{"location":"tuning/","title":"Tuning configuration","text":"<p>Depending on the device and your needs you can configure env vars to make blocking faster or less resource consuming.</p> <p>Some suggestions:</p> <ul> <li> <p>if you don't use IPv6 then disable it via MIKROTIK_IPV6=false</p> </li> <li> <p>devices which have low memory available should use firewall raw only</p> </li> <li> <p>if device cpu usage is high and it processes address-list updates slowly,   or there is noticeable lock wait increase   then try to increase TICKER_INTERVAL</p> </li> <li> <p>force faster addresses expiration from address-lists - it lowers memory usage,   see USE_MAX_TTL and DEFAULT_TTL_MAX</p> </li> <li> <p>if the device still struggles try to disable TRIGGER_ON_UPDATE</p> </li> </ul>"},{"location":"tuning/#example-configurations","title":"Example configurations","text":""},{"location":"tuning/#hap-ax3","title":"HAP AX3","text":"<pre><code>DEFAULT_TTL_MAX=4h\nGOMAXPROCS=1\nIP_FIREWALL_FILTER_RULES_DST=5,6\nIP_FIREWALL_FILTER_RULES_SRC=3,4\nIP_FIREWALL_RAW_RULES_DST=2,3\nIP_FIREWALL_RAW_RULES_SRC=1\nIPV6_FIREWALL_FILTER_RULES_DST=2,3\nIPV6_FIREWALL_FILTER_RULES_SRC=0,1\nIPV6_FIREWALL_RAW_RULES_DST=1,2\nIPV6_FIREWALL_RAW_RULES_SRC=0\nLOG_LEVEL=0\nMIKROTIK_FIREWALL_FILTER_ENABLE=true\nMIKROTIK_FIREWALL_RAW_ENABLE=true\nMIKROTIK_HOST=192.168.1.1:8728\nMIKROTIK_IPV6=false\nMIKROTIK_TLS=false\nTICKER_INTERVAL=15s\nUSE_MAX_TTL=true\n</code></pre>"}]}